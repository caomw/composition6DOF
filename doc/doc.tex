\documentclass[10pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[german, english]{babel} 
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{float}
\usepackage{rotating}

% Kopf und Fußzeile
\usepackage{fancyhdr}
\usepackage{cite}

\author{\\Markus Solbach \\ \href{mailto:solbach@uni-koblenz.de}{\texttt{solbach@uni-koblenz.de}} \\\\  University of the Balearic Islands \\ \href{http://srv.uib.es/}{System, Robotics \& Vision Group} }
\date{\today}


\pagestyle{fancy} %eigener Seitenstil
\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
\fancyhead[L]{\texttt{solbach@uni-koblenz.de}} %Kopfzeile links
\fancyhead[C]{} %zentrierte Kopfzeile
\fancyhead[R]{ 
\begin{tabular}{ll} 
Markus Solbach\\ 
\end{tabular}
} %Kopfzeile rechts
\renewcommand{\headrulewidth}{0.4pt} %obere Trennlinie

\fancyfoot[R]{\thepage} %Seitennummer
\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie


\begin{document}


\title{Transformations in 3D (6 DOF)}
\subtitle{a short overview}
\maketitle\newpage

\section{Introduction}\label{ch:intro}
Adding relative motion, for instance given by odometry (observation), to an absolute state its called \textit{transformation composition}. In our case we deal with a full 3 dimensional composition with 6 degrees of freedom (DOF). With other words it is possible to translate the system in $x, y, z$ direction, what gives us the first 3 DOF and to rotate the system around $\phi, \theta, \psi$ (roll, pitch, yaw), that gives us the missing 3 DOF.
\\\\ In more detail: Let $X$ the state-vector and $Y$ the observation-vector. Defined as follows:
\begin{equation}
X = \begin{bmatrix} x_x \\ y_x \\ z_x \\ \phi_x \\ \theta_x \\ \psi_x \end{bmatrix}, \hspace{15 mm} Y = \begin{bmatrix} x_y \\ y_y \\ z_y \\ \phi_y \\ \theta_y \\ \psi_y \end{bmatrix}
\end{equation}


\section{Transformation Composition}
% plus operator
The \textit{Transformation Composition} is commonly represented by means of the operator $\oplus$, as shown in formula \ref{eq:plus}.
\begin{equation}\label{eq:plus}
X_+ = X \oplus Y
\end{equation}

In our case the \textit{Transformation Composition} Matrix can be derived starting by defining the 3D rotation Matrices for each axis:

\begin{equation}
R(\phi) = \begin{bmatrix} 1 & 0 & 0 & 0 \\0 & \cos(\phi) & -\sin(\phi) & 0\\ 0 & \sin(\phi) & \cos(\phi) & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}
\end{equation} 

\begin{equation}
R(\theta) = \begin{bmatrix} \cos(\theta) & 0 & \sin(\theta) & 0 \\0 & 1 & 0 & 0\\ -\sin(\theta) & 0 & \cos(\theta) & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}
\end{equation}

\begin{equation}
R(\psi) = \begin{bmatrix} \cos(\psi) & -\sin(\psi) & 0 & 0 \\ \sin(\psi) & \cos(\psi) & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}
\end{equation} 

First of all we put all 3 Matrices to one closed Matrix together. Due to rotation is not commutative, we define the multiplication order as follows: $R_x \cdot R_y \cdot R_z$. What gives us $R(\phi, \theta, \psi)$. The solution for $R(\phi, \theta, \psi)$ can be found in formula \ref{eq:R}

\tiny
\begin{equation}
R(\phi, \theta, \psi) = 
\begin{bmatrix}
\cos(\theta)   \cos(\psi) & -\cos(\theta)   \sin(\psi) & \sin(\theta) & 0\\
\sin(\phi)   \sin(\theta)   \cos(\psi) + \cos(\phi)   \sin(\psi) &
-\sin(\phi)   \sin(\theta)   \sin(\psi) + \cos(\phi)   \cos(\psi) & 
-\sin(\phi)   \cos(\theta) & 0 \\
-\cos(\phi)   \sin(\theta)   \cos(\psi) + \sin(\phi)   \sin(\psi) &
\cos(\phi)   \sin(\theta)   \sin(\psi) + \sin(\phi)   \cos(\psi) & 
\cos(\phi)   \cos(\theta) & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}\label{eq:R}
\end{equation}
\normalsize
This Matrix is filled with data from $X$ and is multiplied by the observation vector $Y$, but without the rotation part, this is handled separately. The result gives us the \textit{Transformation Composition} Matrix, as shown in \ref{eq:comp}

\begin{equation*}
X \oplus Y = R(\phi_x, \theta_x, \psi_x) \cdot \begin{bmatrix}
x_y \\
y_y \\
z_y \\
1
\end{bmatrix}
\end{equation*}

\tiny
\begin{equation}
X \oplus Y = \begin{bmatrix} 
x_x + x_y   \cos(\theta_x)   \cos(\psi_x) - y_y   \cos(\theta_x)   \sin(\psi_x) + z_y  (\theta_x) \\ 
y_x + x_y   \left(\sin(\phi_x)   \sin(\theta_x)   \cos(\psi_x) + \cos(\theta_x)   \sin(\psi_x)\right) + y_y   (-\sin(\phi_x)   \sin(\theta_x)   \sin(\psi_x) + \cos(\phi_x)   \cos(\psi_x) ) + z_y   (-\sin(\phi_x)   \cos(\theta_x)) \\ 
z_x + x_y \left(-\cos(\phi_x)   \sin(\theta_x)   \cos(\psi_x) + \sin(\theta_x)   \sin(\psi_x)\right) + y_y   (\cos(\phi_x)   \sin(\theta_x)   \sin(\psi_x) + \sin(\phi_x)   \cos(\psi_x) ) + z_y   (\cos(\phi_x)   \cos(\theta_x)) \\ 
\phi_x + \phi_y\\ 
\theta_x + \theta_y \\ 
\psi_x + \psi_y \end{bmatrix}\label{eq:comp}
\end{equation}
\normalsize

\section{Jacobians}
In the context of EKF-SLAM it is also necessary to derive the Jacobians from the Matrix given in \ref{eq:comp}. In this case we need to calculate two Jacobians. The first with respect to $X$ ($J_{1\oplus}$) and the second with respect to $Y$ ($J_{2\oplus}$).

\begin{frame}

\resizebox{\linewidth}{!}{%
$\displaystyle
J_{1\oplus} = 
\begin{bmatrix}
1& 0& 0& 0& z_y \cos(\theta_x) - x_y \cos(\psi_x) \sin(\theta_x) + y_y \sin(\psi_x) \sin(\theta_x)&                                                                         - y_y \cos(\psi_x) \cos(\theta_x) - x_y \cos(\theta_x) \sin(\psi_x) \\
0& 1& 0& - x_y (\sin(\phi_x) \sin(\psi_x) - \cos(\phi_x) \cos(\psi_x) \sin(\theta_x)) - y_y (\cos(\psi_x) \sin(\phi_x) + \cos(\phi_x) \sin(\psi_x) \sin(\theta_x)) - z_y \cos(\phi_x) \cos(\theta_x)& z_y \sin(\phi_x) \sin(\theta_x) + x_y \cos(\psi_x) \cos(\theta_x) \sin(\phi_x) - y_y \cos(\theta_x) \sin(\phi_x) \sin(\psi_x)& x_y (\cos(\phi_x) \cos(\psi_x) - \sin(\phi_x) \sin(\psi_x) \sin(\theta_x)) - y_y (\cos(\phi_x) \sin(\psi_x) + \cos(\psi_x) \sin(\phi_x) \sin(\theta_x)) \\
0& 0& 1& x_y (\cos(\phi_x) \sin(\psi_x) + \cos(\psi_x) \sin(\phi_x) \sin(\theta_x)) + y_y (\cos(\phi_x) \cos(\psi_x) - \sin(\phi_x) \sin(\psi_x) \sin(\theta_x)) - z_y \cos(\theta_x) \sin(\phi_x)& y_y \cos(\phi_x) \cos(\theta_x) \sin(\psi_x) - x_y \cos(\phi_x) \cos(\psi_x) \cos(\theta_x) - z_y \cos(\phi_x) \sin(\theta_x)& x_y (\cos(\psi_x) \sin(\phi_x) + \cos(\phi_x) \sin(\psi_x) \sin(\theta_x)) - y_y (\sin(\phi_x) \sin(\psi_x) - \cos(\phi_x) \cos(\psi_x) \sin(\theta_x) \\
0& 0& 0& 1& 0& 0 \\
0& 0& 0& 0& 1& 0 \\
0& 0& 0& 0& 0& 1 
\end{bmatrix}
$}
\end{frame}

\tiny
\begin{equation}
J_{2\oplus} = 
\begin{bmatrix} 
\cos( \psi_x) \cos(\theta_x) & -\cos(\theta_x) \sin( \psi_x) & \sin(\theta_x) & 0 & 0 & 0 \\
\cos(\phi_x) \sin( \psi_x) + \cos( \psi_x) \sin(\phi_x) \sin(\theta_x) & \cos(\phi_x) \cos( \psi_x) - \sin(\phi_x) \sin( \psi_x) \sin(\theta_x) & -\cos(\theta_x) \sin(\phi_x) & 0 & 0 & 0 \\
\sin(\phi_x) \sin( \psi_x) - \cos(\phi_x) \cos( \psi_x) \sin(\theta_x) & \cos( \psi_x) \sin(\phi_x) + \cos(\phi_x) \sin( \psi_x) \sin(\theta_x) &  \cos(\phi_x) \cos(\theta_x) & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 
\end{bmatrix}
\end{equation}
\normalsize
\section{Implementation}
An implementation can be found on \href{https://github.com/solbach/composition6DOF}{www.github.com/solbach/composition6DOF}. \\It covers the following points:
\begin{itemize}
\item Full 3D Frame Composition with six degrees of freedom
\item Transformation Composition-Function
\item Jacobians
\item Simple Simulator
\item Written in Matlab (should also work with Octave)
\end{itemize}

%\begin{figure}[ht]
%	\centering
%  \includegraphics[width=.7\textwidth]{img/systemGraph2}
%	\caption{Modelled System with finite capacity region using \textit{JSIMgraph}}
%	\label{im:sys2}
%\end{figure}


\end{document}
